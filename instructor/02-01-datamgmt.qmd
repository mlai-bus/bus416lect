---
title: "02-01-datamgt"
output: html_document
editor_options: 
  chunk_output_type: console
---

# Creating and importing data

Let's look at a couple of ways of creating a small dataset. First, we will generate a matrix and cast it into a tibble. Then we will create a dataset of variables of different type.

## Creating a toy dataset

First, load the required libraries

```{r echo=FALSE}
library(tidyverse)
```

### Creating tibbles directly

```{r}
mydata1 <- tibble(one = 1:10, two = 11:20, three = 21:30)
str(mydata1)
```

### Creating a tibble from a matrix

```{r}
mydata2 <- as_tibble(matrix(1:30, ncol = 3))
names(mydata2) <- c("one", "two", "three")
```

```{r}
nstr <- names(mydata2)
nstr
```

```{r}
str(mydata1)
str(mydata2)
```

### Traditional data.frame approaches

```{r}
mydata1b <- data.frame(one = 1:10, two = 11:20, three = 21:30)
```

```{r}
mydata2b <- as.data.frame(matrix(1:30, ncol = 3))
names(mydata2b) <- c("one", "two", "three")
```

```{r}
str(mydata1b)
str(mydata2b)
```

```{r}
rm(mydata2, mydata1b, mydata2b)
```

```{r}
# empty chunk preserved intentionally
```

### Student exercise: creating a tibble

```{r}
#| eval: false
# Create a tibble called mydata_ex with three columns:
# one = 1:5
# two = 6:10
# three = 11:15
#
# Then inspect its structure using str()
```

## importing data from excel and csv

There are two packages that we will use to import data. `readr` package is used to import csv files and `readxl` is used to read excel files. Though the preference is to use the .csv format. Also, note that the data file is stored in a separate folder, /data within the project folder. This is good practice as it separates out code from data. Some large project may involve setting up two folders: /data_raw and /data_clean.

### Loading libraries for data import

```{r}
library(readr)
library(readxl)
library(skimr)
library(mlbadata)
```

### Reading CSV files

```{r}
roxbury_tb <- read_csv("data/WestRoxbury.csv")
roxbury_df <- read.csv("data/WestRoxbury.csv")
```

### Inspecting imported data

```{r}
skim(roxbury_df)
```

```{r}
roxbury_tb
```

```{r}
skim(roxbury_tb)
```

```{r}
glimpse(roxbury_tb)
glimpse(roxbury_df)
```

### Creating new variables

```{r}
roxbury_tb$extra_area <- roxbury_tb$`GROSS AREA` - roxbury_tb$`LIVING AREA`
```

```{r}
extra_area2 <- roxbury_tb$`GROSS AREA` - roxbury_tb$`LIVING AREA`
```

### Exporting data

```{r}
write_csv(roxbury_tb, "data/new_roxbury.csv")
```

```{r}
write_rds(roxbury_tb, "data/roxbury.rds")
```

```{r}
#roxbury.new <- read_rds("data/roxbury.rds")
```

### Reading Excel files

```{r}
housing.data <- read_excel("data/BostonHousing.xlsx")
```

**Note:** The above method of reading csvs `read_csv()`, works well when you have external data files, ideally, in the same project. Then, put `""` marks in the parenthesis and press `tab`. R will open up the existing file and folders in the current project directory and you can choose the appropriate data file.

However, in general, all the datasets used in this course are contained in the `mlbdadata` library which I have already loaded in the environment. Datasets within this library (or any other `R` library, can be easily loaded using the following command:

### Loading packaged datasets

```{r}
roxbury.df <- mlbadata::WestRoxbury
```

```{r}
glimpse(roxbury.df)
skim(roxbury.df)
```

### Student exercise: reading packaged data

```{r}
#| eval: false
# Load the WestRoxbury dataset from the mlbadata package
# Assign it to an object called roxbury_ex
# Then preview it using glimpse() or skim()
```

There are some important points to note in the `roxbury_tb` dataframe. Some variable names have spaces. The default command, `read.csv()` would have inserted `.` between the words, `TOTAL.VALUE`.

**Accessing a given variable from the data and doing some basic operations:**

There are two common ways to access a variable, one with the $ accessor and one with a column reference. *Each will result in a different class of results and that has implications on what can be done with them*. To get the column names of a dataset, we can use `names()` function:

```{r}
names(mydata1)[2:3]
```

Let's pull out col 2.

### Accessing columns as vectors

```{r}
mydata1$two[1:5]
```

```{r}
mydata1[1:5 , 2]
```

```{r}
mydata1[[2]]
```

```{r}
str(mydata1$two)
class(mydata1$two)
```

The result is a vector object, which is most flexible and permits direct mathematical operations. For example,

```{r}
mean(mydata1$two)
```

```{r}
mean(mydata1[,2])
```

```{r}
summary(mydata1[,2])
```

### Accessing columns as data frames

```{r}
mydata1[ , "two"]
```

```{r}
mydata1[c(3,4,8) , c("one", "three")]
```

```{r}
class(mydata1[, "two"])
str(mydata1[, "two"])
```

```{r}
mydata1[ , 2]
```

```{r}
mydata1[[2]]
```

```{r}
mydata1[1:5, c(1,3)]
```

```{r}
class(mydata1[1:5, c(1,3)])
```

The structure of these objects still is dataframe (tibble). Standard math functions, like `mean()` do not work on datafames but on vectors. Try,

`mean(d2)`

The above function will work over a vector and even a martix and will give us the mean of the entire matrix.

### Working with matrices

```{r}
mymat <- matrix(1:30, nrow = 10)
mymat
```

```{r}
mean(mymat)
max(mymat)
median(mymat)
```

We will learn later on how to apply functions iteratively to elements of a list using a paradigm called `functional programming`.

### Treatment of factor variables

`REMODEL` has three values, "recent, none and old". We want to make this into a factor variable and also make recent as the first level, followed by old and then none. The function `factor()` will make a column into a factor with the levels being sorted in alphabetical order. But here, we will specify our own levels.

```{r}
roxbury_tb$REMODEL <- factor(roxbury_tb$REMODEL,
                         levels = c("Recent", "Old", "None"))
```

```{r}
glimpse(roxbury_tb)
str(roxbury_tb$REMODEL)
```

We can change the levels as well.

```{r}
roxbury_tb$REMODEL <- factor(roxbury_tb$REMODEL,
                         levels = c("None", "Recent", "Old" ))
```

```{r}
str(roxbury_tb$REMODEL)
```

### Student exercise: factor levels

```{r}
#| eval: false
# Recreate the REMODEL factor so that:
# "Old" is the first level,
# followed by "Recent",
# and then "None"
#
# Inspect the result using str()
```

This will be useful in ML tasks. Some algorithms will want the first level as outcome (if coded as 1,2) and some will want the second as the outcome of interest (expect data to be coded as 0,1).



### Some basic tables and pivot tables

`R` has several options of tabulating data or creating pivot tables.

Let's start with a basic table showing how many homes with various number of homes.

```{r}
table(roxbury_tb$ROOMS)
```

Suppose we want to see the frequency of homes with each of these rooms. The function we will use is `prop.table()`, where the above table is input into this function.

```{r}
prop.table(table(roxbury_tb$ROOMS))
```

The above code is very unwieldy. We are basically *piping* the table output into the new function. For this, we can use the `|>` operator (called the pipe operator). This operator will take whatever is preceding the pipe and put it as the *first* argument of the following function.

```{r}
table(roxbury_tb$ROOMS) |> 
  prop.table()
```

```{r}
roxbury_tb$ROOMS |> 
  table() |> 
  prop.table()
```

### Student exercise: one-way tables and proportions

```{r}
#| eval: false
# Create a frequency table for the variable FULL BATH
# Then compute the proportional table using the pipe operator
```

Let's look at a two-way table. We want to see the number of baths for each remodel category.

```{r}
table(roxbury_tb$REMODEL, roxbury_tb$`FULL BATH`)
```

### Student exercise: two-way tables

```{r}
#| eval: false
# Create a two-way table showing:
# REMODEL by ROOMS
```

Now, let's obtain the proportional table for this new two-way table.

```{r}
table(roxbury_tb$REMODEL, roxbury_tb$`FULL BATH`) |> 
  prop.table()
```

By default, frequency distribution is over the entire table. If we want to get this over rows, we can add the `margins = 1` argument.

```{r}
table(roxbury_tb$REMODEL, roxbury_tb$`FULL BATH`) |> 
  prop.table( margin = 1)
```

For column-wise frequency:

```{r}
table(roxbury_tb$REMODEL, roxbury_tb$`FULL BATH`) |> 
  prop.table( margin = 2)
```

### Student exercise: row vs column proportions

```{r}
#| eval: false
# Using a two-way table of REMODEL and FULL BATH:
# 1. Compute row-wise proportions
# 2. Compute column-wise proportions
```

We can also obtain Excel-like pivot tables with data presented as other summary stats like mean, median, sum etc by using the `dplyr` library, which is covered in the next section.


