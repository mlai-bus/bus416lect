---
title: "01-01-intro"
output: html_document
editor_options: 
  chunk_output_type: console
---

# Heading 1

## Heading 2

### R as a *Sophisticated* Calculator

We can use R just like a calculator. Let’s start with some very basic operations.

```{R}
2 + 2
```

```{R}
exp(4)
```

```{R}
1 + 2
```

```{R}
exp(1)
```

```{R}
log(exp(1))
```

```{R}
2^3
```

#### Student practice

```{R}
#| eval: false
# Try a few calculations of your own
___ + ___
exp(___)
___ ^ ___
```

------------------------------------------------------------------------

### Vectors

`R` is a **vectorised** language. A vector is a collection of objects of the same type.\
Many operations in R are applied **element-wise** across vectors.

A vector is created using the `c()` function, where elements are separated by commas.

```{R}
# Create a numeric vector
x <- c(1, 3, 4, 8, 16, 31.99, 5)
```

```{R}
# Basic vector summaries
sum(x)
x
str(x)
length(x)
```

Because R is vectorised, we can operate on all elements at once.

```{R}
# Vectorized arithmetic
x1 <- 5 * x
x1

5 * x + 2
```

We can also combine vectors and sequences.

```{R}
# Combining sequences and vectors
x_1 <- 1:7 * x * 7:1
x_1
```

```{R}
# Element-wise transformations
log(x)
```

#### Student practice

```{R}
#| eval: false
# Create a vector with at least 5 numbers
x <- c(___, ___, ___, ___, ___)

# Perform a vectorized operation
___ * x + ___
```

------------------------------------------------------------------------

### Some other useful code snippets

Subsetting vectors allows us to select specific elements.

```{R}
# Subsetting by position
x[c(1, 4)]
x[-c(2, 3, 5)]
x[c(2, 3, 5)]
```

We can also generate patterned vectors.

```{R}
# Repetition patterns
ones <- rep(1, 10)
ones

rep(c(1, 2, 3), each = 2)
rep(c(1, 2, 3), 2)
rep(c(1, 2, 3), c(3, 2, 1))
```

Sequences are often useful for indexing and simulations.

```{R}
seq(from = 2, to = 20, by = 7)
```

```{R}
trend <- 1981:2005
trend
rm(trend)
```

#### Student practice

```{R}
#| eval: false
# Create a repeating pattern
rep(c(___, ___), each = ___)

# Create a sequence with a custom step size
seq(from = ___, to = ___, by = ___)
```

------------------------------------------------------------------------

### R Objects

Let us now work with some **data** and **packages**.

Packages are user-written code that extend R’s functionality beyond the base version.\
Once packages are installed on a system, they only need to be **loaded** once per session.

```{R}
library(tidyverse)
library(gapminder)
library(hablar)
library(skimr)
```

We will work with the `gapminder` dataset.

```{R}
# Load the dataset
life.expt <- gapminder::gapminder
```

Let’s take an initial look at the data.

```{R}
head(life.expt)
tail(life.expt)
```

Understanding the structure of the data is extremely important.

```{R}
str(life.expt)
skim(life.expt)
glimpse(life.expt)
```

We can also check the type of object we are working with.

```{R}
class(life.expt)
print(life.expt)
```

We can access individual columns using the `$` operator.

```{R}
mean(life.expt$lifeExp)
```

Finally, we convert some variables to more appropriate types.

```{R}
life.expt <- life.expt %>%
  convert(
    fct(continent),
    num(year)
  )

class(life.expt$continent)
```

#### Student practice

```{R}
#| eval: false
# Compute a summary statistic for a column
mean(life.expt$___)
```

```{R}
#| eval: false
# Inspect the structure of the dataset
___(life.expt)
```

```{R}
#| eval: false
# Convert continent to a factor and year to numeric
life.expt <- life.expt %>%
  convert(
    fct(___),
    num(___)
  )
```

------------------------------------------------------------------------

### Indexing and subsetting

R provides powerful tools for indexing data.\
Notice the difference between indexing with `[]` and using the `$` accessor.

```{R}
# Compare indexing approaches
str(life.expt[, 4])
str(life.expt$lifeExp)
```

The `sort()` function works on vectors, not on data frames or tibbles.

```{R}
sort(life.expt$lifeExp)
```

Let’s generate some random data to illustrate ordering.

```{R}
set.seed(9876)
x <- runif(10, 1, 100)
x <- ceiling(x)
x
```

```{R}
sort(x)
index <- order(x)
index
x[index]
rank(x)
rank(-x)
```

We can apply the same ideas to a dataset.

```{R}
ind <- order(life.expt$lifeExp)
head(life.expt[ind, ])
```

#### Student practice

```{R}
#| eval: false
# Order the dataset by life expectancy (highest first)
ind <- order(-life.expt$___)
head(life.expt[ind, ])
```

------------------------------------------------------------------------

### Logical indexing

Logical conditions allow us to filter data using TRUE/FALSE values.

```{R}
africa <- life.expt$continent == "Africa"
poor.health <- life.expt$lifeExp < 45

ind <- africa & poor.health
life.expt[ind, ]
```

As we will see later, these operations become much cleaner using the **tidyverse** approach.
