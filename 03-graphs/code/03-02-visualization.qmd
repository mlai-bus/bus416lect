---
title: "03-02-visualization"
author: "Dr. Jeff Jacob"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Chapter 3: Data Visualization

In this unit, we will recreate Ch 3 figures primarily using the ggplot framework.

Load the relevant packages

```{r}

#| echo: FALSE
#| output: FALSE
library(tidyverse)
library(ggthemes)
library(patchwork)
library(forecast)
library(caret)
library(treemapify)
library(treemap)
library(GGally)
library(ggcorrplot)
library(readr)
library(skimr)
library(tsibble)
library(fable)
library(lubridate)
library(feasts)

library(mlbadata)

```

Get the relevant datasets

```{r, echo = F}
housing.df <- read_csv("../BostonHousing.csv")

# amtrak.df <- read_csv("Amtrak.csv")

#Since we have loaded all the textbook's datasets
amtrak <- mlbadata::Amtrak
glimpse(amtrak)

#The above format is dataframe. Preferred format is tibble
amtrak.df <- as_tibble(mlbadata::Amtrak)

str(bank.df <- as_tibble(mlbadata::UniversalBank) ) 
utilities.df <- as_tibble(mlbadata::Utilities)
ebay.df <- as_tibble(mlbadata::eBayTreemap)
```

## 1. Some Basic Time Series Charts

To create time series plot, we will first specify a time series object and then use `autoplot()` to create the relevant ggplot. amtrak.df contains monthly data on ridership. Here, the index is monthly. We will first make a month object that is in a tidy format.

```{r}
# str(amtrak.df)
amtrak.df1 <- amtrak.df |> 
  mutate(Month = dmy(Month))

glimpse(amtrak.df1)

# Here month is now in date format. The problem is that the periodicity
#  of this series is monthly. So we have to extract that.

amtrak.ts <- amtrak.df1 |> 
 mutate(yrMth = yearmonth(Month)) |> 
  select(-Month) |> 
  as_tsibble(index = yrMth)

glimpse(amtrak.ts)
```

Let's unpack what we did above. We first converted the Month, which initially was a character vector to a date field using the `lubridate()` package. Date field will however have a periodicity of 365 in tsibble, even though our data is monthly.

We need to explicitly call the `yearmonth()` function in `tsibble` to convert the date field to the correct monthly format. While invoking `glimpse()` notice that the format is now monthly.

```{r}
autoplot(amtrak.ts) +
  labs(title = "Amtrak monthly ridership",
       y = "Passengers in `000")
```

We can see the seasonal component in these plots.

```{r}
amtrak.ts |> 
  gg_season() +
  labs(title = "Separate monthly series") 

amtrak.ts |> 
  gg_subseries() +
  labs(title = "Separate plots by each month")

```

We can use the `filter()` function from dplyr to zoom in.

```{r}
amtrak.ts |> 
  filter(year(yrMth) == 1996) |> 
  autoplot()
```

Instead of `group_by()`, tsibbles work with `index_by()`, which can then be followed by `summarize()`

```{r}
amtrak.ts |> 
  index_by( yr = year(yrMth)) |> 
  summarize(avg.rides = mean(Ridership)) |> 
  autoplot(avg.rides) +
  labs(y = "Average Annual Ridership")
str(amtrak.ts)
# We can add more tick marks as well
amtrak.ts |> 
  index_by( yr = year(yrMth)) |> 
  summarize(tot.rides = sum(Ridership)) |> 
  filter(yr != 2004) |> 
  autoplot(tot.rides) +
  labs(y = "Total Annual Ridership") +
  scale_x_continuous(breaks = scales::extended_breaks(12)) +
  theme(axis.text.x = element_text(angle = 60, vjust = 0.5))
```

## 2. Cross Sectional data plots

### Bar Plots.

Bar plots can be plotted for both numerical and categorical variables. First, let us create a simple bar chart for CAT_MEDV. We will summarize the data and pipe it into ggplot. For categorical variables, we can plot counts. First let's look at the summary.

```{r}

housing.df |>
  group_by(CHAS, CAT_MEDV) |> 
  summarise(count = n()) 


```

Now, pipe this into a bar chart. Observe the options for the bar chart.

```{r}
housing.df |>
  group_by(CHAS, CAT_MEDV) |> 
  summarise(count = n()) |> 
  ggplot(aes(x = factor(CHAS))) +
  geom_bar(aes(y = count), stat = "identity") 

housing.df |>
  group_by(CHAS, CAT_MEDV) |> 
  summarise(count = n()) |> 
  ggplot(aes(x = factor(CHAS))) +
  geom_bar(aes(y = count, fill = factor(CAT_MEDV)),
               stat = "identity") 
housing.df |>
  group_by(CHAS, CAT_MEDV) |> 
  summarise(count = n()) |> 
  ggplot(aes(x = factor(CHAS))) +
  geom_bar(aes(y = count, fill = factor(CAT_MEDV)),
               position = "fill", stat = "identity") 

housing.df |>
  group_by(CHAS, CAT_MEDV) |> 
  summarise(count = n()) |> 
  ggplot(aes(x = factor(CHAS))) +
  geom_bar(aes(y = count, fill = factor(CAT_MEDV)),
               position = "dodge", stat = "identity") 
```

Another approach is to use `stat_summary()` directly in ggplot

```{r}
gg2 <- housing.df |> 
  ggplot(aes(x = factor(CHAS))) +
  stat_summary(aes(y = MEDV), fun = "mean", geom = "bar") +
  scale_y_continuous(breaks = seq(0,30,5))

gg2
```

### Density Plots

One can obtain a density plot, separated by CHAS:

```{r}
s1 <-  housing.df |> 
  ggplot(aes(x = MEDV)) +
  geom_density(aes(color = factor(CHAS)))
```

Notice that the y axis is in decimals. To get a histogram:

```{r}
s2 <- housing.df |> 
  ggplot(aes(x = MEDV)) +
  geom_histogram(aes(fill = factor(CHAS)), alpha = 0.2, color = "blue")

s1 / s2
```

`alpha =` controls the transparency. The scale here is count. Due to the layered nature of ggplot, we could add both the graphs simultaneously. Due the different scales however, there will be a problem.

```{r}
housing.df |> 
  ggplot(aes(x = MEDV)) +
  geom_histogram(aes(fill = factor(CHAS)), alpha = 0.5) +
  geom_density(aes(color = factor(CHAS)))
```

The density plot is not visible! To avoid that, we have to explicitly specify density as the y argument in the aesthetics function.

```{r}

gg3 <- housing.df |> 
  ggplot(aes(x = MEDV,y = after_stat(density))) +
  geom_histogram(aes( fill = factor(CHAS)), alpha = 0.25) +
  geom_density(aes( color = factor(CHAS)), size = 1) +
  labs(title = "Density plot of MEDV") 
gg3
```

We can collect all this using `patchwork`

```{r}
gg2  + gg3
```

### Box and Whisker Plot

The x variable is usually a factor

```{r}
housing.df |> 
  ggplot(aes(y = MEDV, x = factor(CHAS))) +
  geom_boxplot() +
  labs(title = "Box and Whisker Plot")
```

### Heatmap

A heatmap represents the various numbers in a matrix with color, with the color intensity varying by the magnitude of the numbers. A basic heatmap can be made from the correlation matrix of the housing data.

```{r}
heatmap(cor(housing.df))

# default provides dendograms. They can be avoided

heatmap(cor(housing.df), Rowv = NA, Colv = NA )

```

To use ggplot function `geom_tile()`, which let's one put in values, we first need to reshape the correlation matrix to a long (tidy) format.

```{r}
cormat <- data.frame(round(cor(housing.df), 2))
cormat$xvar <- rownames(cormat)
cor.tidy <- cormat |> 
  pivot_longer(!xvar, names_to = "yvar", values_to = "corrval")

# now pass this to ggplot

cor.tidy |> 
  ggplot(aes(x = xvar, y = yvar, fill = corrval) ) +
  geom_tile()

# customize it

cor.tidy |> 
  ggplot(aes(x = xvar, y = yvar, fill = corrval) ) +
  geom_tile(color = "white",
            size = 0.5)
# Add text

cor.tidy |> 
  ggplot(aes(x = xvar, y = yvar, fill = corrval) ) +
  geom_tile(color = "white",
            size = 0.5) +
  geom_text(aes(label = corrval), color = "white", size = 3) +
  theme(axis.text.x = element_text(angle = 90, vjust = .5))

```

### Multidimensional plots

We will create a plot of NOX vs LSTAT

```{r}

gg5 <- housing.df |> 
  ggplot(aes(x = LSTAT, y = NOX, color = factor(CHAS))) +
  geom_point() +
  labs(title = "Scatter of Nox vs LSTAT")

gg5
```

Now, a bar plot of average median value based on RAD, faceted by CHAS

```{r}
plot.data <- housing.df |> 
  #hablar::convert(fct(CHAS, RAD)) |> 
  group_by(factor(CHAS), factor(RAD)) |> 
  summarise(avg_MEDV = mean(MEDV))

gg6 <- plot.data |> 
  ggplot(aes(x = `factor(RAD)`, y = `avg_MEDV`)) +
  geom_bar(stat = "identity") +
  facet_wrap(vars(`factor(CHAS)`), nrow = 2) +
  labs(title = "Avg Median Value per \naccess to higways",
      subtitle = "Faceted by CHAS")

gg6

gg5 + gg6  
```

### Pairwise scatter chart matrix

```{r}
ggpairs(housing.df[, c(1, 3, 12, 13)])
```

### Changing the scale to see the patterns more clearly

```{r}
gg7 <- housing.df |> 
  ggplot(aes(x = CRIM, y = MEDV)) +
  geom_point() +
  labs(title = "Scatter chart with raw scale")

gg8 <- housing.df |> 
  ggplot(aes(x = CRIM, y = MEDV)) +
  geom_point() +
  scale_x_log10() +
  scale_y_log10() +
  labs(title = "Scatter chart with log scale")

gg7 + gg8
```

### Scatter with text label

Ggplot allows us to label points with values

```{r}
utilities.df |> 
  ggplot(aes(x = Sales, y = Fuel_Cost, label = Company)) +
  geom_text()

#We can adjust the position of text and also include points

utilities.df |> 
  ggplot(aes(x = Sales, y = Fuel_Cost, label = Company)) +
  geom_point() +
  geom_text( angle = 25, nudge_x = 0.01,
             hjust = 0, #right (left = 1)
             vjust =1, #bottom (top = 0)
             size = 2) #in mm
```

### Several data points

We can use `geom_jitter()`

```{r}
gg8 <- bank.df |> 
  ggplot(aes(x = Income, y = CCAvg)) +
  geom_point()

gg8

gg9  <- bank.df |> 
  ggplot(aes(x = Income, y = CCAvg, color = factor(Securities.Account),
             alpha = 0.5)) +
  geom_jitter() +
  scale_x_log10() +
  scale_y_log10()

gg9
# Comparison
gg8/gg9
```

### Parallel Coordinate plots

These charts enable us to quickly identify the distribution of the continuous variables grouped by a categorical variable.

```{r}
gg10 <- housing.df |>
  mutate(CAT_MEDV = factor(CAT_MEDV)) |> 
  ggparcoord(columns = 1:13,
             groupColumn = 14,
             scale = "uniminmax") #values will be re scaled to [0,1]

gg10
```

### Parts of the whole data

Treemaps help us visualize parts of the whole data. They are especially useful if the follows a hierarchical ordering. For example, in the ebay dataset, ordering is item category, sub-category, and brand.

```{r}

# add column for negative feedback
ebay.df$negative.feedback <- 1* (ebay.df$Seller.Feedback < 0)

# Take the averages of neg feedback and high bid
ebay.tm <- ebay.df |>
  group_by(Category, Sub.Category, Brand)|>
  summarise(Avg_HighBid = mean(High.Bid, na.rm = TRUE),
            Avg_NegFeedback = mean(negative.feedback, na.rm = TRUE))|>ungroup
# draw treemap


ebay.tm |> 
treemap( index = c("Category","Sub.Category", "Brand"), 
    vSize = "Avg_HighBid", vColor = "Avg_NegFeedback",
    align.labels = list(c("left", "top"), c("right", "bottom"), c("center", "center")),
    palette ="Pastel1", type = "manual",title = "")
```

```{r}


ebay.tm |>
  ggplot(aes(area = Avg_HighBid, fill = Avg_NegFeedback,
             label = Category,
             subgroup = Sub.Category,
             subgroup2 = Brand)) +
  geom_treemap() +
  geom_treemap_text(color = "white", size = 15, grow = TRUE) +
  geom_treemap_subgroup_text(color = "white", size = 10, place = "center") +
  geom_treemap_subgroup2_text(color = "red", size = 6) +
  geom_treemap_subgroup_border(color = "white", size = 5) +
  geom_treemap_subgroup2_border(color = "blue", size = 2) +
  scale_fill_viridis_c()
```

```{r}
library(ggplot2)
library(mlbadata)
utility.toy <- mlbadata::Utilities|>slice(1:15)
utility.toy |>  
  ggplot(aes(x = Company, y = RoR)) +
  geom_segment(aes(x=Company, xend=Company, y=0, yend=RoR))+
  geom_point(color = " red", size = 3)

# There are two ways of fixing this. First one retains the axis direction

utility.toy |>
  ggplot(aes(x = Company, y = RoR)) +
  geom_segment(aes(x=Company, xend=Company, y=0, yend=RoR))+
  geom_point(color = " red", size = 3) +
  theme(axis.text.x = element_text(angle = 60, vjust = 0.5))

```

```{r}
#Easier way
utility.toy |>
  ggplot(aes(x = Company, y = RoR)) +
  geom_segment(aes(x=Company, xend=Company, y=0, yend=RoR))+
  geom_point(color = " red", size = 3,) +
  coord_flip()
```
